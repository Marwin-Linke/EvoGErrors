import math
import time

st = time.time()

def calculator(inp: str) -> float:
    if not str(inp).find("inc") == -1:
        return eval(str(inp), {"inc": math.increment}) # math.increment does not exist -> AttributeError

    if not str(inp).find("factorial") == -1:
        return eval(str(inp))

    if not str(inp).find("is_int") == -1:
        return eval(str(inp))
    
    return eval(
        str(inp), {
            "sqrt": math.sqrt, # square roots of negative numbers are not defined -> ValueError
            "sin": math.sin,
            "cos": math.cos,
            "tan": math.tan,
            "log": math.log # the logarithm is only defined for positive numbers -> ValueError
            }
    )

def factorial(n):
    if n >= 2:
        return n * factorial(n) # infinite recursion -> RecursionError
    else:
        return 1

def is_int(inp):
    assert isinstance(inp, int) # if inp is not an integer -> AssertionError
    return True

# Make sure you use the OracleResult from the evogfuzz library
from evogfuzz.oracle import OracleResult

def oracle(inp: str):
    """
    This function serves as an oracle or intermediary that catches and handles exceptions 
    generated by the 'calculator' function. The oracle function is used in the context of fuzz testing.
    It aims to determine whether an input triggers a bug in the 'calculator' function.

    Args:
        inp (str): The input string to be passed to the 'calculator' function.

    Returns:
        OracleResult: An enumerated type 'OracleResult' indicating the outcome of the function execution.
            - OracleResult.NO_BUG: Returned if the calculator function executes without any exception or only with CalculatorSyntaxError
            - OracleResult.BUG: Returned if the calculator function raises a ValueError exception, indicating a potential bug.
    """
    try:
        calculator(inp)
    except ValueError as e:
        return OracleResult.BUG
    except Exception as ex:
        return OracleResult.NO_BUG
    return OracleResult.NO_BUG

initial_inputs = []

for inp in initial_inputs:
    print(inp.ljust(20), oracle(inp))

from fuzzingbook.Grammars import Grammar, is_valid_grammar

CALCGRAMMAR: Grammar = {
    "<start>":
        ["<start1>"],

    "<start1>":
        ["<expr>", "<term> / <term>"],

    "<expr>":
        ["<function>(<term>)"],

    "<function>":
        ["sqrt", "tan", "cos", "sin", "log", "len", "inc", "factorial", "is_int"],
    
    "<term>":
        ["-<value>", "<value>"], 
    
    "<value>":
        ["<integer>.<integer>", "<integer>"],

    "<integer>":
        ["<digit><integer>", "<digit>"],

    "<digit>":
        ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
}
    
assert is_valid_grammar(CALCGRAMMAR)

from evogfuzz.evogfuzz_class import EvoGFuzz

epp = EvoGFuzz(
    grammar=CALCGRAMMAR,
    oracle=oracle,
    inputs=initial_inputs,
    iterations=10
)

found_exception_inputs = epp.fuzz()
print(f"EvoGFuzz found {len(found_exception_inputs)} bug-triggering inputs!")

# print only the first 20 bug-triggering inputs
for inp in list(found_exception_inputs)[:20]:
    print(str(inp))
print(epp.get_last_grammar())

# for the evaluation experiments (saves the output in a file)
# uncomment for evaluation
"""
et = time.time()
elapsed = et - st
grammar_output = epp.get_last_grammar()

# Specify the correct path to the output file
with open("evogfuzz_output.txt", "a") as f:
    f.write("Runtime: "+str(elapsed)+"\n")
    f.write("BugInputs: "+str(len(found_exception_inputs))+"\n")
    f.write(str(grammar_output)+"\n")
"""